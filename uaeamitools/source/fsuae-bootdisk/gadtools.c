/*
** Source code generated by GadToolsBox 3.0 (c) by Tomasz Muszynski
** GUI designed by: 
*/

#include<stdio.h>
#include<proto/exec.h>
#include<exec/memory.h>
#include<proto/gadtools.h>
#include<proto/graphics.h>
#include<intuition/pointerclass.h>
#include<intuition/imageclass.h>
#include<libraries/iffparse.h>
#include<proto/intuition.h>
#include<proto/utility.h>
#include<gadgets/popupmenu.h>
#include<intuition/gadgetclass.h>
#include"gadtools.h"
#include"gadtools_cat.h"

TEXT VER_STRING[]=VER_SVER;

struct Screen *Scr=NULL;
struct DrawInfo *DrawInfo=NULL;
APTR VisualInfo=NULL;
TEXT ScrTitle[256];
TEXT ScrPubName[30];
UWORD ScrWidth=0;
UWORD ScrHeight=0;
UWORD ScrDepth=0;
ULONG ScrDisplayID=0x50041000;
Class *PopUpMenuClass=NULL;
struct TextAttr *Font, Attr;
UWORD FontX, FontY;
BOOL GadgetLocaleDone[CNTWND_WINDOWS];
BOOL WindowLocaleDone[CNTWND_WINDOWS];
BOOL MenuLocaleDone[CNTMN_MENUS];


/* MainWindow Window structures */
struct Window *MainWindowWnd=NULL;
struct Gadget *MainWindowGList=NULL;
struct Gadget *MainWindowGadgets[CNT_MainWindow];
struct IntuiMessage MainWindowMsg;


/* MainWindow Window tags */
ULONG MainWindowWTags[]=
{
	WA_Left, 90, WA_Top, 92, WA_Width, 251, WA_Height, 229, WA_Title, (ULONG) MSG_MainWindow_WND, WA_IDCMP, IDCMP_CLOSEWINDOW|BUTTONIDCMP|LISTVIEWIDCMP, WA_Flags, WFLG_CLOSEGADGET|WFLG_DRAGBAR|WFLG_DEPTHGADGET|WFLG_SIMPLE_REFRESH|WFLG_ACTIVATE|WFLG_NEWLOOKMENUS, WA_FontAdaptive, TRUE, TAG_DONE
};

/* MainWindow Gadget structures */

/* MainWindow Gadget tags */
ULONG MainWindowGTags[]=
{
	BUTTON_KIND, PLACETEXT_IN, GA_ToggleSelect, FALSE, GA_Text, (ULONG) MSG_BT_ADD_GAD, GA_Left, 2, GA_Top, 150, GA_Width, 26, GA_Height, 26, GA_UserData, (ULONG) FN_BT_ADD_Clicked, TAG_DONE,
	BUTTON_KIND, PLACETEXT_IN, GA_ToggleSelect, FALSE, GA_Text, (ULONG) MSG_BT_REMOVE_GAD, GA_Left, 32, GA_Top, 150, GA_Width, 26, GA_Height, 26, GA_UserData, (ULONG) FN_BT_REMOVE_Clicked, TAG_DONE,
	LISTVIEW_KIND, PLACETEXT_LEFT, GTLV_ScrollWidth, 16, GA_Text, (ULONG) MSG__GAD, GA_Left, 3, GA_Top, 3, GA_Width, 237, GA_Height, 145, GA_UserData, (ULONG) FN__Clicked, TAG_DONE,
	POPUPMENU_KIND, NULL, PUMG_Active, 0, PUMG_NewLook, FALSE, GA_Left, 62, GA_Top, 150, GA_Width, 178, GA_Height, 26, GA_UserData, (ULONG) FN_CY_PLATFORM_Clicked, TAG_DONE,
	BUTTON_KIND, PLACETEXT_IN, GA_ToggleSelect, FALSE, GA_Text, (ULONG) MSG_BT_BOOT_GAD, GA_Left, 2, GA_Top, 182, GA_Width, 238, GA_Height, 29, GA_UserData, (ULONG) FN_BT_BOOT_Clicked, TAG_DONE
};

/* Application functions */

UWORD InitApplication()
{
	if(!(PopUpMenuClass=CreatePopUpMenuClass())) return GTBERR_OPENLIB_POPUPMENU;
	return GTBERR_OK;
}

void FreeApplication()
{
	if(PopUpMenuClass) DisposePopUpMenuClass(PopUpMenuClass); PopUpMenuClass=NULL;
}

STRPTR GetCatString(APTR fcstr)
{
	return ((struct FC_Type *)fcstr)->Str;
}

struct Gadget *CreateGadgetExA(UWORD offx,UWORD offy,UWORD offr,UWORD offb,struct Gadget *prev,struct TagItem *tags)
{
	struct Gadget *g;
	struct NewGadget ng;
	ULONG kind,flags,x,y,w,h;
	BOOL rx=0,ry=0,rw=0,rh=0;
	struct TagItem *ti;
	
	kind=tags[0].ti_Tag;
	flags=tags[0].ti_Data;
	tags=&tags[1];

	if(ti=FindTagItem(GA_Left,tags)) x=AdaptX(ti->ti_Data)+offx;
	else { x=AdaptX(GetTagData(GA_RelRight,0,tags))-offr; rx=TRUE; }

	if(ti=FindTagItem(GA_Top,tags)) y=AdaptY(ti->ti_Data)+offy;
	else { y=AdaptY(GetTagData(GA_RelBottom,0,tags))-offb; ry=TRUE; }

	if(ti=FindTagItem(GA_Width,tags)) w=AdaptX(ti->ti_Data);
	else { w=AdaptX(GetTagData(GA_RelWidth,0,tags))-x-offr; rw=TRUE; }

	if(ti=FindTagItem(GA_Height,tags)) h=AdaptY(ti->ti_Data);
	else { h=AdaptY(GetTagData(GA_RelHeight,0,tags))-y-offb; rh=TRUE; }

	switch(kind)
	{
		case BUTTON_KIND:
		case CHECKBOX_KIND:
		case INTEGER_KIND:
		case LISTVIEW_KIND:
		case MX_KIND:
		case NUMBER_KIND:
		case CYCLE_KIND:
		case PALETTE_KIND:
		case SCROLLER_KIND:
		case SLIDER_KIND:
		case STRING_KIND:
		case TEXT_KIND:
			ng.ng_LeftEdge=x;
			ng.ng_TopEdge=y;
			ng.ng_Width=w;
			ng.ng_Height=h;
			ng.ng_Flags=flags;
			ng.ng_UserData=(APTR)GetTagData(GA_UserData,0,tags);
			ng.ng_GadgetID=GetTagData(GA_ID,0,tags);
			ng.ng_GadgetText=(char *)GetTagData(GA_Text,0,tags);
			ng.ng_VisualInfo=VisualInfo;
			ng.ng_TextAttr=Font;
			g=CreateGadgetA(kind,prev,&ng,tags);
			if(!g) return g;
			if(GetTagData(GA_ToggleSelect,0,tags)) g->Activation|=GACT_TOGGLESELECT;
			if(rx) g->Flags|=GFLG_RELRIGHT;
			if(ry) g->Flags|=GFLG_RELBOTTOM;
			if(rw) g->Flags|=GFLG_RELWIDTH;
			if(rh) g->Flags|=GFLG_RELHEIGHT;
			break;
		case POPUPMENU_KIND:
			g=(struct Gadget *)NewObject(PopUpMenuClass,NULL,
					(rx?GA_RelRight:GA_Left), x, (ry?GA_RelBottom:GA_Top), y, (rw?GA_RelWidth:GA_Width), w, (rh?GA_RelHeight:GA_Height), h, (prev?GA_Previous:TAG_IGNORE),prev,TAG_MORE,tags);
			break;
	}
	return g;
}

void DeleteGadgetExA(struct Gadget *g,struct TagItem *tags)
{
	switch(tags[0].ti_Tag)
	{
		case COLORWHEEL_KIND:
		case GRADIENTSLIDER_KIND:
		case PAGE_KIND:
		case POPUPMENU_KIND:
		case PROGRESS_KIND:
		case TAPEDECK_KIND:
		case TEXTFIELD_KIND:
		case TREEVIEW_KIND:
			DisposeObject(g);
			break;
		case TOOLIMAGE_KIND:
			g->GadgetRender=g->SelectRender=NULL;
			break;
	}
}

struct Window *OpenWindowTagsEx(ULONG tags,...)
{
	struct Gadget *g=NULL;
	struct Window *win;
	struct TagItem *ti,*clone=NULL;
	BOOL tbg=FALSE,rx=FALSE,ry=FALSE,rw=FALSE,rh=FALSE;
	ULONG left,top,width,height;

	clone=CloneTagItems((struct TagItem *)&tags);
	if(ti=FindTagItem(WA_ToolDragBar,clone))
	{
		if(g=AllocMem(sizeof(struct Gadget),MEMF_ANY|MEMF_CLEAR))
		{
			g->LeftEdge=0;
			g->TopEdge=0;
			g->Flags=GFLG_GADGHNONE;
			g->GadgetType=GTYP_WDRAGGING;
			g->UserData=(APTR)DRAG_ID;
			if(ti->ti_Data==TOOL_HORIZ)
			{
				g->Activation=GACT_TOPBORDER|GACT_BORDERSNIFF;
				g->Width=32767;
				g->Height=8;
			}
			else
			{
				g->Activation=GACT_LEFTBORDER|GACT_BORDERSNIFF;
				g->Width=8;
				g->Height=32767;
			}
		}
		else return NULL;
		ti->ti_Tag=TAG_IGNORE;
	}

	if(ti=FindTagItem(WA_RelWidth,clone))
	{
		rw=TRUE;
		width=(Scr->Width)-ti->ti_Data;
		ti->ti_Tag=TAG_IGNORE;
	}
	if(ti=FindTagItem(WA_RelHeight,clone))
	{
		rh=TRUE;
		height=(Scr->Height)-ti->ti_Data;
		ti->ti_Tag=TAG_IGNORE;
	}

	if(ti=FindTagItem(WA_CenterX,clone))
	{
		rx=TRUE;
		left=(Scr->Width/2)-(GetTagData(WA_Width,GetTagData(WA_InnerWidth,width,clone),clone)/2);
		ti->ti_Tag=TAG_IGNORE;
	}
	if(ti=FindTagItem(WA_CenterY,clone))
	{
		ry=TRUE;
		top=(Scr->Height/2)-(GetTagData(WA_Height,GetTagData(WA_InnerHeight,height,clone),clone)/2);
		ti->ti_Tag=TAG_IGNORE;
	}
	if(ti=FindTagItem(WA_RelRight,clone))
	{
		rx=TRUE;
		left=(Scr->Width)-(GetTagData(WA_Width,GetTagData(WA_InnerWidth,width,clone),clone))-ti->ti_Data;
		ti->ti_Tag=TAG_IGNORE;
	}
	if(ti=FindTagItem(WA_RelBottom,clone))
	{
		ry=TRUE;
		top=(Scr->Height)-(GetTagData(WA_Height,GetTagData(WA_InnerHeight,height,clone),clone))-ti->ti_Data;
		ti->ti_Tag=TAG_IGNORE;
	}

	if(ti=FindTagItem(WA_Gadgets,clone))
	{
		if(g)
		{
			g->NextGadget=(struct Gadget *)ti->ti_Data;
			ti->ti_Data=(ULONG)g;
			tbg=TRUE;
		}
		if(ti->ti_Data==NULL) ti->ti_Tag=TAG_IGNORE;
	}

	if(ti=FindTagItem(WA_FontAdaptive,clone))
	{
		width=AdaptX(width);
		height=AdaptY(height);
		ti->ti_Tag=TAG_IGNORE;
		if(ti=FindTagItem(WA_Width,clone)) ti->ti_Data=AdaptX(ti->ti_Data);
		if(ti=FindTagItem(WA_Height,clone)) ti->ti_Data=AdaptY(ti->ti_Data);
	}

	if(!(win=OpenWindowTags(NULL,
			rx?WA_Left:TAG_IGNORE,left,
			ry?WA_Top:TAG_IGNORE,top,
			rw?WA_Width:TAG_IGNORE,width,
			rh?WA_Height:TAG_IGNORE,height,
			TAG_MORE,(ULONG)clone)))
		if(g) FreeMem(win,sizeof(struct Gadget));

	if(clone) FreeTagItems(clone);
	return win;
}

void CloseWindowEx(struct Window *win)
{
	struct Gadget *g,*drag=NULL;

	g=win->FirstGadget;
	while(g)
	{
		if(((ULONG)g->UserData)==DRAG_ID) { drag=g; break; }
		g=g->NextGadget;
	}
	CloseWindow(win);
	if(drag) FreeMem(drag,sizeof(struct Gadget));
}

void CalcLeftTop(UWORD *offx,UWORD *offy,struct TagItem *tags)
{
	struct TagItem *ti;
	BOOL bl;

	*offx=0;
	*offy=0;

	if(ti=FindTagItem(WA_Borderless,tags))
		bl=ti->ti_Data;
	else
		bl=((GetTagData(WA_Flags,NULL,tags)&WFLG_BORDERLESS)?TRUE:FALSE);

	if(ti=FindTagItem(WA_ToolDragBar,tags))
	{
		if(ti->ti_Data==TOOL_HORIZ)
		{
			(*offy)+=8;
			if(!bl) (*offx)+=Scr->WBorLeft;
		}
		else
		{
			(*offx)+=8;
			if(!bl) (*offy)+=Scr->WBorTop;
		}
	}
	else
	{
		if(!bl)
		{
			(*offx)+=Scr->WBorLeft;
			if(GetTagData(WA_Title,NULL,tags))
				(*offy)+=Scr->WBorTop+Scr->RastPort.TxHeight+1;
			else
				(*offy)+=Scr->WBorTop;
		}
	}
}

void CalcRightBottom(UWORD *offx,UWORD *offy,struct TagItem *tags)
{
	struct TagItem *ti;
	BOOL bl,sg,sbb,sbr;
	UWORD sw,sh;
	struct Image *im;

	*offx=0;
	*offy=0;

	if(ti=FindTagItem(WA_Borderless,tags))
		bl=ti->ti_Data;
	else
		bl=(GetTagData(WA_Flags,NULL,tags)&WFLG_BORDERLESS);

	if(ti=FindTagItem(WA_SizeGadget,tags))
		sg=ti->ti_Data;
	else
		sg=(GetTagData(WA_Flags,NULL,tags)&WFLG_SIZEGADGET);

	if(ti=FindTagItem(WA_SizeBBottom,tags))
		sbb=ti->ti_Data;
	else
		sbb=(GetTagData(WA_Flags,NULL,tags)&WFLG_SIZEBBOTTOM);

	if(ti=FindTagItem(WA_SizeBRight,tags))
		sbr=ti->ti_Data;
	else
		sbr=(GetTagData(WA_Flags,NULL,tags)&WFLG_SIZEBRIGHT);

	if(im=(struct Image *)NewObject(NULL, SYSICLASS,
		SYSIA_DrawInfo, DrawInfo,
		SYSIA_Which, SIZEIMAGE,
		SYSIA_Size, (Scr->Flags & SCREENHIRES ? SYSISIZE_MEDRES : SYSISIZE_LOWRES),
		TAG_DONE))
	{
		sw=im->Width;
		sh=im->Height;
		DisposeObject((Object *)im);
	}
	else
	{
		sw=18;
		sh=10;
	}

	if(!bl)
	{
		if(sg && (!sbb) && (!sbr)) { (*offx)+=sw; (*offy)+=Scr->WBorBottom; }
		if(sg && (sbb) && (!sbr)) { (*offx)+=Scr->WBorRight; (*offy)+=sh; }
		if(sg && (!sbb) && (sbr)) { (*offx)+=sw; (*offy)+=Scr->WBorBottom; }
		if(sg && sbb && sbr) { (*offx)+=sw; (*offy)+=sh; }
		if((!sg) && (sbb) && (!sbr)) { (*offx)+=Scr->WBorRight; (*offy)+=sh; }
		if((!sg) && (!sbb) && (sbr)) { (*offx)+=sw; (*offy)+=Scr->WBorBottom; }
		if((!sg) && (sbb) && (sbr)) { (*offx)+=sw; (*offy)+=sh; }
	}
}
UWORD AdaptX(UWORD value)
{
	return((UWORD)(((FontX*value)+4)/8));
}

UWORD AdaptY(UWORD value)
{
	return((UWORD)(((FontY*value)+4)/8));
}

void CalcAdaptivity(UWORD width, UWORD height)
{
	Font = &Attr;
	Font->ta_Name = (STRPTR)Scr->RastPort.Font->tf_Message.mn_Node.ln_Name;
	Font->ta_YSize = FontY = Scr->RastPort.Font->tf_YSize;
	FontX = Scr->RastPort.Font->tf_XSize;

	if(width && height)
		if((AdaptX(width) > Scr->Width) || (AdaptY(height) > Scr->Height)) goto UseTopaz;
	return;

UseTopaz:
	Font->ta_Name = (STRPTR)"topaz.font";
	FontX = FontY = Font->ta_YSize = 8;
}

void FixGadgetTags(struct TagItem *tags)
{
	ULONG kind,a;
	UBYTE **labels;
	struct TagItem *ti;
	struct Node *node;

	kind=tags[0].ti_Tag;
	tags=&tags[1];

	if(kind!=TOOLIMAGE_KIND && kind!=DATATYPE_KIND) if(ti=FindTagItem(GA_Text,tags)) ti->ti_Data=(ULONG) GetCatString((APTR)ti->ti_Data);

	switch(kind)
	{
		case LISTVIEW_KIND:
			if(ti=FindTagItem(GTMX_Labels,tags))
				for(node=(struct Node *)ti->ti_Data;node->ln_Succ;node=node->ln_Succ)
					node->ln_Name=GetCatString((APTR)node->ln_Name);
			break;
		case MX_KIND:
			if(ti=FindTagItem(GTMX_Labels,tags))
				for(labels=(UBYTE **) ti->ti_Data,a=0;labels[a];a++) labels[a]=(UBYTE *) GetCatString((APTR)labels[a]);
			break;
		case NUMBER_KIND:
			if(ti=FindTagItem(GTNM_Format,tags)) ti->ti_Data=(ULONG) GetCatString((APTR)ti->ti_Data);
			break;
		case CYCLE_KIND:
			if(ti=FindTagItem(GTCY_Labels,tags))
				for(labels=(UBYTE **) ti->ti_Data,a=0;labels[a];a++) labels[a]=(UBYTE *) GetCatString((APTR)labels[a]);
			break;
		case SLIDER_KIND:
			if(ti=FindTagItem(GTSL_LevelFormat,tags)) ti->ti_Data=(ULONG) GetCatString((APTR)ti->ti_Data);
			break;
		case STRING_KIND:
			if(ti=FindTagItem(GTST_String,tags)) ti->ti_Data=(ULONG) GetCatString((APTR)ti->ti_Data);
			break;
		case TEXT_KIND:
			if(ti=FindTagItem(GTTX_Text,tags)) ti->ti_Data=(ULONG) GetCatString((APTR)ti->ti_Data);
			break;
		case POPUPMENU_KIND:
			if(ti=FindTagItem(PUMG_Labels,tags))
				for(node=(struct Node *)ti->ti_Data;node->ln_Succ;node=node->ln_Succ)
					node->ln_Name=GetCatString((APTR)node->ln_Name);
			break;
	}
}

void FixWindowTags(struct TagItem *tags)
{
	struct TagItem *ti;

	if(ti=FindTagItem(WA_Title,tags)) ti->ti_Data=(ULONG) GetCatString((APTR)ti->ti_Data);
	if(ti=FindTagItem(WA_ScreenTitle,tags)) ti->ti_Data=(ULONG) GetCatString((APTR)ti->ti_Data);
}

void FixMenus(struct NewMenu *menu)
{
	ULONG a;

	for(a=0;menu[a].nm_Type!=NM_END;a++)
		if((menu[a].nm_Label!=NM_BARLABEL) && (menu[a].nm_Label))
		{
			menu[a].nm_CommKey=GetCatString(menu[a].nm_Label);
			menu[a].nm_Label=menu[a].nm_CommKey+2;
			if(menu[a].nm_CommKey[0]=='\0') menu[a].nm_CommKey=NULL;
		}
}

/* Screen functions */

UWORD SetupScreen(UBYTE Num)
{
	UWORD OffX,OffY;

	sprintf(ScrPubName,"",Num);
	sprintf(ScrTitle,GetCatString(MSG_SCREENTITLE_SCR),Num);
	if(!(Scr=OpenScreenTags(NULL,
				SA_Left, 0,
				SA_Top, 0,
				SA_Width, ScrWidth,
				SA_Height, ScrHeight,
				SA_Depth, ScrDepth,
				SA_DisplayID, ScrDisplayID,
				SA_Type, PUBLICSCREEN,
				SA_PubName, ScrPubName,
				SA_LikeWorkbench, TRUE,
				SA_SharePens, TRUE,
				SA_Title, ScrTitle,
				TAG_DONE))) return GTBERR_OPENSCREEN;
	PubScreenStatus(Scr,PSNF_PRIVATE);

	OffX=Scr->WBorLeft; OffY=Scr->RastPort.TxHeight+Scr->WBorTop+1;

	CalcAdaptivity(0,0);
	if(!(VisualInfo=GetVisualInfo(Scr,TAG_DONE))) return GTBERR_VISUALINFO;

	if(!(DrawInfo=GetScreenDrawInfo(Scr))) return GTBERR_SCRDRAWINFO;

	return GTBERR_OK;
}

void CloseDownScreen()
{
	if(DrawInfo) FreeScreenDrawInfo(Scr,DrawInfo); DrawInfo=NULL;
	if(VisualInfo) FreeVisualInfo(VisualInfo); VisualInfo=NULL;
	if(Scr) CloseScreen(Scr); Scr=NULL;
}

int HandleIDCMP_MainWindow()
{
	struct IntuiMessage *m;
	int (*func)(void);
	BOOL running = TRUE;

	while(m=GT_GetIMsg(MainWindowWnd->UserPort))
	{
		CopyMem((APTR)m,(APTR)&MainWindowMsg,sizeof(struct IntuiMessage));
		GT_ReplyIMsg(m);
		switch(MainWindowMsg.Class)
		{
			case IDCMP_CLOSEWINDOW:
				running=FN_CloseWindow_MainWindow();
				if(running > 1) return running;
				break;
		}
	}
	return(running);
}

UWORD OpenWindow_MainWindow()
{
	struct Gadget *g;
	UWORD lc,tc;
	UWORD OffX,OffY;

	if(!(g=CreateContext(&MainWindowGList))) return GTBERR_CREATECONTEXT;

	CalcLeftTop(&OffX,&OffY,(struct TagItem *)MainWindowWTags);
	if(FindTagItem(WA_FontAdaptive,(struct TagItem *)MainWindowWTags)) CalcAdaptivity(GetTagData(WA_Width,GetTagData(WA_InnerWidth,GetTagData(WA_RelWidth,0,(struct TagItem *)MainWindowWTags),(struct TagItem *)MainWindowWTags),(struct TagItem *)MainWindowWTags),GetTagData(WA_Height,GetTagData(WA_InnerHeight,GetTagData(WA_RelHeight,0,(struct TagItem *)MainWindowWTags),(struct TagItem *)MainWindowWTags),(struct TagItem *)MainWindowWTags)); else { FontX=8; FontY=8; }


	for(lc=0,tc=0;lc<CNT_MainWindow;lc++)
	{
		if(!GadgetLocaleDone[WND_MainWindow]) FixGadgetTags((struct TagItem *)&MainWindowGTags[tc]);
		MainWindowGadgets[lc]=g=CreateGadgetExA(OffX,OffY,0,0,g,(struct TagItem *) &MainWindowGTags[tc]);
		tc+=2;
		while(MainWindowGTags[tc]!=TAG_DONE) tc+=2;
		tc++;
		if(!(g)) return GTBERR_CREATEGADGET;
	}

	GadgetLocaleDone[WND_MainWindow]=TRUE;

	if(!WindowLocaleDone[WND_MainWindow]) FixWindowTags((struct TagItem *)MainWindowWTags);
	WindowLocaleDone[WND_MainWindow]=TRUE;

	if(!(MainWindowWnd=OpenWindowTagsEx(
				WA_Gadgets,MainWindowGList,
				WA_CustomScreen, Scr,
				TAG_MORE, MainWindowWTags ))) return GTBERR_OPENWINDOW;

	GT_RefreshWindow(MainWindowWnd,NULL);
	return GTBERR_OK;
}

void CloseWindow_MainWindow()
{
	UWORD lc,tc;

	if(MainWindowWnd) CloseWindowEx(MainWindowWnd); MainWindowWnd=NULL;
	if(MainWindowGList)
	{
		for(lc=0,tc=0;lc<CNT_MainWindow;lc++)
		{
			if(MainWindowGTags[tc]==TOOLIMAGE_KIND) DeleteGadgetExA(MainWindowGadgets[lc],(struct TagItem *)&MainWindowGTags[tc]);
			tc+=2;
			while(MainWindowGTags[tc]!=TAG_DONE) tc+=2;
			tc++;
		}
		FreeGadgets(MainWindowGList);
		MainWindowGList=NULL;
		for(lc=0,tc=0;lc<CNT_MainWindow;lc++)
		{
			if(MainWindowGTags[tc]!=TOOLIMAGE_KIND) DeleteGadgetExA(MainWindowGadgets[lc],(struct TagItem *)&MainWindowGTags[tc]);
			tc+=2;
			while(MainWindowGTags[tc]!=TAG_DONE) tc+=2;
			tc++;
		}
	}
}

